

# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#      1: 1
#      3: 1,3
#      6: 1,2,3,6
#     10: 1,2,5,10
#     15: 1,3,5,15
#     21: 1,3,7,21
#     28: 1,2,4,7,14,28

# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?

from functools import reduce
import math

class prime(object):
	"""docstring for prime"""
	def __init__(self, primes=[2, ]):
		super(prime, self).__init__()
		self.primes = primes

	def currentprimes(self):
		return self.primes

	def isprime(self, n):
		if n == 2:
			return True
		elif n > 1:
			for prime in self.primes:
				if n in self.primes:
					return True
				elif prime >= int(math.sqrt(n)+1):
					self.primes.append(n)
					return True
				elif n % prime == 0:
					return False
		else:
			return False

	def nextprime(self, n=1):
		while True:
			n += 1
			if n > len(self.primes):
				currentnumber = self.primes[-1]+1
				while not self.isprime(currentnumber):
					currentnumber += 1
			yield self.primes[n-2]

	def giveprimes(self, n):
		"""returns list up to and including n"""
		if n > self.primes[-1]:
			for current in range(self.primes[-1], n+1):
				self.isprime(current)
		return [prime for prime in self.primes if prime <= n]

	def trialdivision(self, n):
		assert(n >= 2)
		if self.isprime(n):
			return [n]
		primelist = self.giveprimes(int(math.sqrt(n)+1))
		for prime in primelist:
			if n % prime == 0:
				return [prime] + self.trialdivision(n=n/prime)

	def divisors(self, n):
		listofprimes = self.trialdivision(n)
		factors = {prime:listofprimes.count(prime)+1 for prime in listofprimes}
		return reduce(lambda x, y: x*y, factors.values())


def trianglenumber(n):
	return sum(range(n+1))

def factors(n):
    """Gives list of proper divisors, excludes n"""
    counter = 1
    divisors = []
    while counter < int(n**0.5)+1:
        if n%counter == 0:
            divisors.append(counter)
            if counter != n/counter:    #remove "and test != 1" if you want to include n itself
            	# prevents entering the same number twice
            	divisors.append(n/counter)
        counter += 1
    divisors.sort()
    return divisors




if __name__ == '__main__':
	# n = 1
	# triangle = trianglenumber(n)
	# l = factors(triangle)
	# while len(l) < 500:
	# 	n += 1
	# 	triangle = trianglenumber(n)
	# 	l = factors(triangle)
	# print n, triangle, l

	# p = prime()
	# for n in range(2, 1000):
	# 	# print "give primes", n, p.giveprimes(n)
	# 	print
	# 	# print "triaL", n, p.trialdivision(n)
	# 	print "divisors", n, p.divisors(n)

	n = 2
	p = prime()
	while p.divisors(trianglenumber(n)) < 500:
		n += 1
	print trianglenumber(n)
